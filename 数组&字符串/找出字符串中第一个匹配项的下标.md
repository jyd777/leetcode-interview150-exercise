# 找出字符串中第一个匹配项的下标

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

 

**示例 1：**

```
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

**示例 2：**

```
输入：haystack = "leetcode", needle = "leeto"
输出：-1
解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。
```

 

**提示：**

- `1 <= haystack.length, needle.length <= 104`
- `haystack` 和 `needle` 仅由小写英文字符组成



**法一：滑动窗口**

```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = haystack.size();
        int m = needle.size();
        if(m==0)
            return 0;
        if(n==0)
            return -1;
        // 滑动窗口大小为m
        for(int i=0;i<=n-m;i++){
            bool match = true;
            for(int j=0;j<m;j++){
                if(haystack[i+j]!=needle[j]){
                    match = false;
                    break;
                }
            }
            if(match)
                return i;
        }
        return -1;
    }
};
```

**法二：KMP算法**

法一在出现有一个字符不匹配时，就需要回退needle到第一个字符重新开始匹配，这会浪费很多时间

KMP通过提前计算needle的最长公共前后缀的长度来知道不匹配时回退到哪个位置，来减少前缀的重复匹配

```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = haystack.size();
        int m = needle.size();
        if(m==0)
            return 0;
        if(n==0)
            return -1;
        // 构建next数组（记录回退位置）
        vector<int> next(m,0);
        int j=0;// 最长公共前后缀的长度
        for(int i=1;i<m;i++){
            // 当前字符不匹配，回退到前一个位置
            while(j>0 && needle[i] != needle[j])
                j = next[j-1];
            if(needle[i] == needle[j])
                j++;
            next[i] = j; // 记录当前位置的最长公共前后缀长度
        }
        // KMP匹配
        j = 0; // needle中当前匹配的位置
        for(int i=0;i<n;i++){
            // 如果字符不匹配，则回退j
            while(j>0 && haystack[i] != needle[j])
                j = next[j-1];// 因为needle[j-1]和hayback[i-1]还是匹配的
            // 如果当前字符匹配，则向后移动j
            if(haystack[i] == needle[j])
                j++;
            if(j == m)
                return i-m+1;
        }
        return -1;
    }
};
```

这是一个非常好的问题！让我详细解释为什么当字符不匹配时，`j` 要回退到 `next[j-1]`。

## 关键理解：next数组的真正含义

### 1. next[j-1] 的含义

**`next[j-1]` 表示：**
- 在 `needle[0...j-1]` 这个子串中
- **前缀和后缀的最长公共长度**
- 这个长度就是我们可以**跳过的比较次数**

### 2. 为什么可以跳过？

**核心思想：**
- 如果 `needle[0...j-1]` 有长度为 `next[j-1]` 的公共前后缀
- 那么我们已经知道 `needle[0...next[j-1]-1]` 这部分是匹配的
- 所以可以直接从 `next[j-1]` 位置开始比较，而不需要从头开始

## 具体例子分析

**例子：needle = "ABABC"**

```
当前状态：
haystack: "...ABAB..."
needle:    "ABABC"
                ↑
                j=4 (当前匹配到第4个字符'C')

next数组: [0,0,1,2,0]
                ↑
                next[3]=2
```

**当 `needle[4]='C'` 不匹配时：**

**步骤1：理解当前匹配状态**

```
已经匹配的部分：needle[0...3] = "ABAB"
当前不匹配：needle[4] = 'C'
```

**步骤2：分析 "ABAB" 的前后缀**

```
"ABAB" 的前缀和后缀：
前缀：["A", "AB", "ABA", "ABAB"]
后缀：["B", "AB", "BAB", "ABAB"]

最长公共部分：前缀"AB" = 后缀"AB"，长度 = 2
所以 next[3] = 2,也就是下一个匹配是从j=2开始匹配
```

**步骤3：为什么可以回退到2？**

```
因为：
1. 我们已经知道 haystack 中匹配了 "ABAB"
2. "ABAB" 的后缀 "AB" 和前缀 "AB" 相同
3. 所以 haystack 中 "ABAB" 后面的部分，一定和 needle 中 "AB" 后面的部分匹配

因此：
- 不需要重新比较 needle[0] 和 needle[1]
- 可以直接从 needle[2] 开始比较
- 这就是 j = next[j-1] = 2 的原因

之前状态：
haystack: "...ABAB..."
needle:    "ABABC"
                ↑
                j=4 (当前匹配到第4个字符'C')
之后状态：        
haystack: "...ABAB..."
needle:      "ABABC"
                ↑
                j=2 (当前匹配到第2个字符'A')
```

**数学证明**

**设：**
- `needle[0...j-1]` 有长度为 `next[j-1]` 的公共前后缀
- 即：`needle[0...next[j-1]-1] = needle[j-next[j-1]...j-1]`

**则：**
- 当 `needle[j]` 不匹配时
- 我们可以跳过前 `next[j-1]` 个字符的比较
- 直接从 `needle[next[j-1]]` 开始比较

**复杂度分析**

**滑动窗口解法：**

- 时间复杂度：O((n-m+1) × m) = O(n×m)

- 空间复杂度：O(1)

**KMP算法：**

- 时间复杂度：O(n + m)

- 空间复杂度：O(m)