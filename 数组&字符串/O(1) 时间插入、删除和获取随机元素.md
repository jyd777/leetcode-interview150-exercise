# O(1) 时间插入、删除和获取随机元素

实现`RandomizedSet` 类：

- `RandomizedSet()` 初始化 `RandomizedSet` 对象
- `bool insert(int val)` 当元素 `val` 不存在时，向集合中插入该项，并返回 `true` ；否则，返回 `false` 。
- `bool remove(int val)` 当元素 `val` 存在时，从集合中移除该项，并返回 `true` ；否则，返回 `false` 。
- `int getRandom()` 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 **相同的概率** 被返回。

你必须实现类的所有函数，并满足每个函数的 **平均** 时间复杂度为 `O(1)` 。

 

**示例：**

```
输入
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
输出
[null, true, false, true, 2, true, false, 2]

解释
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。
randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。
randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。
randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。
randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。
randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。
randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。
```

 

**提示：**

- `-231 <= val <= 231 - 1`
- 最多调用 `insert`、`remove` 和 `getRandom` 函数 `2 * ``105` 次
- 在调用 `getRandom` 方法时，数据结构中 **至少存在一个** 元素。

## 解法分析

### 为什么单独用unordered_map不行？

**问题分析：**
- `insert()` 和 `remove()` 用哈希表确实可以O(1)
- 但 `getRandom()` 需要等概率随机返回，哈希表无法做到这点！

**哈希表的问题：**
1. 哈希表的键是散列存储的，无法通过索引直接访问
2. 要随机选择，需要遍历所有元素，时间复杂度O(n)

### 正确解法：数组 + 哈希表

**核心思想：**
- **数组**：存储所有元素，支持O(1)随机访问
- **哈希表**：存储 `{元素值 → 数组下标}` 的映射，支持O(1)查找

**数据结构设计：**

```cpp
class RandomizedSet {
private:
    vector<int> nums;// 存储元素
    unordered_map<int,int> val_to_idx; // 数值->数组下标
public:
    RandomizedSet() {
        
    }
    
    bool insert(int val) {
        if(val_to_idx.count(val))
            return false;
        nums.push_back(val);
        val_to_idx[val] = nums.size()-1;
        return true;
    }
    
    bool remove(int val) {
        if(!val_to_idx.count(val))
            return false;
        // 用最后一个值来替代现在要删除的值，然后把最后一个值删掉
        int idx = val_to_idx[val];
        int last_val = nums.back();
        nums[idx] = last_val;
        val_to_idx[last_val] = idx;
        nums.pop_back();
        val_to_idx.erase(val);
        return true;
    }
    
    int getRandom() {
        int random_idx = rand() % nums.size();
        return nums[random_idx];
    }
};

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet* obj = new RandomizedSet();
 * bool param_1 = obj->insert(val);
 * bool param_2 = obj->remove(val);
 * int param_3 = obj->getRandom();
 */
```

### 删除操作的优化

**问题：** 数组中间删除元素需要O(n)时间移动后续元素

**解决：** 用最后一个元素替换要删除的元素，然后删除最后一个

**删除过程示例：**
```
删除元素2：
原数组: [1, 2, 3, 4]  (删除下标1的元素2)
映射:   {1→0, 2→1, 3→2, 4→3}

步骤1: 用最后元素4替换位置1的元素2
数组:   [1, 4, 3, 4]
步骤2: 更新元素4的映射
映射:   {1→0, 2→1, 3→2, 4→1}
步骤3: 删除最后一个元素和映射
数组:   [1, 4, 3]
映射:   {1→0, 3→2, 4→1}
```

### 时间复杂度
- `insert()`: O(1) - 数组末尾插入 + 哈希表插入
- `remove()`: O(1) - 交换 + 数组末尾删除 + 哈希表删除  
- `getRandom()`: O(1) - 数组随机访问

### 空间复杂度
- O(n) - 数组存储n个元素，哈希表存储n个映射