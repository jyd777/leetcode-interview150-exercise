# 分发糖果

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子中，评分更高的那个会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

 

**示例 1：**

```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

**示例 2：**

```
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
```

 

**提示：**

- `n == ratings.length`
- `1 <= n <= 2 * 104`
- `0 <= ratings[i] <= 2 * 104`



### 方法：贪心 + 两次遍历

**核心思路：**
1. 从最小值开始分发，确保最小值孩子获得1个糖果
2. 分别处理从左到右和从右到左的递增关系
3. 取两次遍历的最大值，确保满足所有约束

**算法步骤：**
1. 初始化所有孩子糖果数为1
2. 从左到右遍历：如果右边评分更高，右边糖果数 = 左边糖果数 + 1
3. 从右到左遍历：如果左边评分更高，左边糖果数 = max(左边糖果数, 右边糖果数 + 1)
4. 求和返回

**代码实现：**

```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        //初始每个人一个糖果
        vector<int> candies(n,1);
        // 根据关系再多分发糖果
        // 从左向右处理递增,处理candies[i]和candies[i-1]
        for(int i=1;i<n;i++){
            if(ratings[i-1] < ratings[i])
                candies[i] = candies[i-1]+1;
        }
        // 从右向左处理递减，处理candies[i]和candies[i+1]
        for(int i=n-2;i>=0;i--){
            if(ratings[i] > ratings[i+1])
                candies[i] = max(candies[i+1]+1, candies[i]);
        }
        // 统计糖果数量
        int ret = 0;
        for(int candy : candies)
            ret += candy;
        return ret;
    }
};
```

### 为什么这样是对的？

**关键洞察：**
1. **最小值孩子必须获得1个糖果**：因为这是最小值，不可能更少
2. **递增序列**：从左到右，评分递增时糖果数递增
3. **递减序列**：从右到左，评分递减时糖果数递增
4. **取最大值**：确保同时满足左右两个方向的约束

**执行过程示例：**

对于 `ratings = [1, 0, 2]`：

```
初始: candies = [1, 1, 1]

从左到右:
i=1: ratings[1]=0 < ratings[0]=1, 不更新
i=2: ratings[2]=2 > ratings[1]=0, candies[2] = 1+1 = 2
结果: candies = [1, 1, 2]

从右到左:
i=1: ratings[1]=0 < ratings[2]=2, 不更新  
i=0: ratings[0]=1 < ratings[1]=0, 不更新
结果: candies = [1, 1, 2]

最终: [1, 1, 2], 总和 = 5
```

### 时间复杂度
- **时间复杂度：** O(n) - 两次遍历数组
- **空间复杂度：** O(n) - 存储每个孩子的糖果数

### 为什么不能只从左到右？

**反例：** `ratings = [1, 2, 2]`
```
只从左到右: candies = [1, 2, 1]  ❌ 不满足第二个2比第一个2糖果多
正确结果:  candies = [1, 2, 1]  ✅ 满足所有约束
```

**关键点：** 当评分相等时，糖果数可以相等