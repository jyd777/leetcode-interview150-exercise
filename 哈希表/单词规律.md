# 单词规律

给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `s` 中的每个非空单词之间存在着双向连接的对应规律。

 

**示例1:**

```
输入: pattern = "abba", s = "dog cat cat dog"
输出: true
```

**示例 2:**

```
输入:pattern = "abba", s = "dog cat cat fish"
输出: false
```

**示例 3:**

```
输入: pattern = "aaaa", s = "dog cat cat dog"
输出: false
```

 

**提示:**

- `1 <= pattern.length <= 300`
- `pattern` 只包含小写英文字母
- `1 <= s.length <= 3000`
- `s` 只包含小写英文字母和 `' '`
- `s` **不包含** 任何前导或尾随对空格
- `s` 中每个单词都被 **单个空格** 分隔



```cpp
class Solution {
public:
    bool wordPattern(string pattern, string s) {
      vector<string> words = split(s);

      if(pattern.length() != words.size())
        return false;
      
      unordered_map<char,string> c2w;
      unordered_map<string,char> w2c;

      for(int i=0;i<pattern.length();i++){
        char c = pattern[i];
        string word = words[i];
        if(c2w.find(c) != c2w.end()){
          if(c2w[c] != word)
            return false;
        }
        else{
          if(w2c.find(word) != w2c.end())
            return false;
          c2w[c] = word;
          w2c[word] = c;
        }
      }
      return true;
    }
private:
    vector<string> split(string s){
      vector<string> words;
      string word = "";
      for(char c:s){
        if(c == ' '){
          if(!word.empty()){
            words.push_back(word);
            word = "";
          }
        }
        else
          word += c;
      }
      // 这句句子的最后一个单词
      if(!word.empty())
        words.push_back(word);
      return words;
    }
};
```

