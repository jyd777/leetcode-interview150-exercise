# 长度最小的子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

 

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

 

**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 104`

 

**进阶：**

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。



**法一：滑动窗口**

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int left = 0, sum = 0;
        int min_len = INT_MAX;
        for(int right = 0; right<n; right++){
            sum += nums[right];
            // 如果大于target，则要收缩滑动窗口左边的部分
            while(sum >= target){
                min_len = min(min_len, right-left+1);
                sum -= nums[left];
                left++;
            }
        }
        return min_len == INT_MAX ? 0: min_len;
    }
};
```

**法二：前缀和 + 二分查找**

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int min_len = INT_MAX;
        vector<int> pre_sum(n+1,0);
        // 构造前缀和数组（pre_sum[i]是（下标0~i-1的数组元素之和）
        for(int i=0;i<n;i++)
            pre_sum[i+1] = pre_sum[i] + nums[i];
        // 对每个起始位置，用二分查找满足条件的结束位置
        for(int i=0;i<n;i++){
            // 找到最小的j，使得prefixSum[j] - prefixSum[i] >= target
            int left = i+1, right = n;
            while(left <= right){
                int mid = (left+right)/2;
                int sum = pre_sum[mid]-pre_sum[i];
                if(sum >= target){
                    min_len = min(min_len, mid-i);
                    right = mid-1;
                }
                else
                    left = mid+1;
            }
        }
        return min_len == INT_MAX ? 0:  min_len;
        
    }
};
```

**复杂度分析**

**滑动窗口解法：**

- 时间复杂度：O(n)，每个元素最多被访问两次

- 空间复杂度：O(1)

**前缀和 + 二分查找：**

- 时间复杂度：O(n log n)，外层循环O(n)，内层二分O(log n)

- 空间复杂度：O(n)，需要存储前缀和数组